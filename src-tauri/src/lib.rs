mod platform;

// Include the embedded assets generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_assets.rs"));

use platform::{ActiveWindowInfo, DisplayInfo, DisplayManager, WindowManager};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::path::PathBuf;
use tauri::{
    AppHandle, Manager, State, WebviewUrl, WebviewWindowBuilder, Emitter,
    tray::{TrayIconBuilder, TrayIconEvent, MouseButton},
    menu::{Menu, MenuItem, PredefinedMenuItem},
};

#[derive(Debug, Serialize, Deserialize, Clone)]
struct OverlayColor {
    r: u8,
    g: u8,
    b: u8,
    a: f32, // opacity from 0.0 to 1.0
}

impl Default for OverlayColor {
    fn default() -> Self {
        Self {
            r: 0,
            g: 0,
            b: 0,
            a: 0.5,
        }
    }
}

impl OverlayColor {
    fn to_rgba_string(&self) -> String {
        format!("rgba({}, {}, {}, {})", self.r, self.g, self.b, self.a)
    }

    fn to_hex_string(&self) -> String {
        format!("#{:02x}{:02x}{:02x}", self.r, self.g, self.b)
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct AppConfig {
    overlay_color: OverlayColor,
    is_dimming_enabled: bool,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            overlay_color: OverlayColor::default(),
            is_dimming_enabled: true,
        }
    }
}

// Global state for managing overlays and focus tracking
struct AppState {
    overlays: Arc<Mutex<HashMap<String, tauri::WebviewWindow>>>,
    is_dimming_enabled: Arc<Mutex<bool>>,
    current_active_display: Arc<Mutex<Option<String>>>,
    overlay_color: Arc<Mutex<OverlayColor>>,
    config_path: Arc<Mutex<Option<PathBuf>>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            overlays: Arc::new(Mutex::new(HashMap::new())),
            is_dimming_enabled: Arc::new(Mutex::new(true)), // Start with dimming enabled
            current_active_display: Arc::new(Mutex::new(None)),
            overlay_color: Arc::new(Mutex::new(OverlayColor::default())),
            config_path: Arc::new(Mutex::new(None)),
        }
    }
}

impl AppState {
    async fn load_config(&self, app_handle: &AppHandle) -> Result<(), String> {
        let config_dir = app_handle.path().app_config_dir()
            .map_err(|e| format!("Failed to get config directory: {}", e))?;

        // Create config directory if it doesn't exist
        if let Err(e) = std::fs::create_dir_all(&config_dir) {
            println!("Warning: Failed to create config directory: {}", e);
        }

        let config_file = config_dir.join("spotlight-dimmer-config.json");

        // Store config path for later use
        {
            let mut path = self.config_path.lock().unwrap();
            *path = Some(config_file.clone());
        }

        if config_file.exists() {
            match std::fs::read_to_string(&config_file) {
                Ok(content) => {
                    match serde_json::from_str::<AppConfig>(&content) {
                        Ok(config) => {
                            let color_string = config.overlay_color.to_rgba_string();
                            let dimming_enabled = config.is_dimming_enabled;

                            {
                                let mut color = self.overlay_color.lock().unwrap();
                                *color = config.overlay_color;
                            }
                            {
                                let mut enabled = self.is_dimming_enabled.lock().unwrap();
                                *enabled = dimming_enabled;
                            }
                            println!("Loaded config: overlay color = {}, dimming enabled = {}",
                                color_string, dimming_enabled);
                        }
                        Err(e) => {
                            println!("Warning: Failed to parse config file, using defaults: {}", e);
                        }
                    }
                }
                Err(e) => {
                    println!("Warning: Failed to read config file, using defaults: {}", e);
                }
            }
        } else {
            println!("Config file doesn't exist, using defaults");
        }

        Ok(())
    }

    async fn save_config(&self) -> Result<(), String> {
        let config_path = {
            let path = self.config_path.lock().unwrap();
            path.clone()
        };

        if let Some(path) = config_path {
            let config = {
                let color = self.overlay_color.lock().unwrap();
                let enabled = self.is_dimming_enabled.lock().unwrap();
                AppConfig {
                    overlay_color: color.clone(),
                    is_dimming_enabled: *enabled,
                }
            };

            let content = serde_json::to_string_pretty(&config)
                .map_err(|e| format!("Failed to serialize config: {}", e))?;

            std::fs::write(&path, content)
                .map_err(|e| format!("Failed to write config file: {}", e))?;

            println!("Saved config to {:?}", path);
        }

        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct FocusChangeEvent {
    active_window: ActiveWindowInfo,
    active_display: DisplayInfo,
}

// Tauri commands
#[tauri::command]
async fn get_displays() -> Result<Vec<DisplayInfo>, String> {
    #[cfg(windows)]
    {
        let display_manager = platform::WindowsDisplayManager;
        display_manager.get_displays()
    }
    #[cfg(not(windows))]
    {
        Err("Platform not supported yet".to_string())
    }
}

// Helper function for lightweight display count checking
fn get_display_count() -> Result<usize, String> {
    #[cfg(windows)]
    {
        let display_manager = platform::WindowsDisplayManager;
        display_manager.get_display_count()
    }
    #[cfg(not(windows))]
    {
        Err("Platform not supported yet".to_string())
    }
}

#[tauri::command]
async fn get_active_window() -> Result<ActiveWindowInfo, String> {
    #[cfg(windows)]
    {
        let window_manager = platform::WindowsWindowManager;
        window_manager.get_active_window()
    }
    #[cfg(not(windows))]
    {
        Err("Platform not supported yet".to_string())
    }
}

#[tauri::command]
async fn toggle_dimming(
    state: State<'_, AppState>,
    app_handle: AppHandle,
) -> Result<bool, String> {
    println!("Toggle dimming called!");

    // Fix: Use scope to drop mutex guard before await
    let is_enabled = {
        let mut enabled = state.is_dimming_enabled.lock().unwrap();
        *enabled = !*enabled;
        *enabled
    };

    println!("Dimming is now: {}", is_enabled);

    if is_enabled {
        println!("Creating overlays...");
        create_overlays(&app_handle, &state).await?;
        println!("Overlays creation completed");
    } else {
        println!("Closing overlays...");
        close_all_overlays(&state).await?;
        println!("Overlays closed");
    }

    Ok(is_enabled)
}

#[tauri::command]
async fn is_dimming_enabled(state: State<'_, AppState>) -> Result<bool, String> {
    let is_enabled = state.is_dimming_enabled.lock().unwrap();
    Ok(*is_enabled)
}

#[tauri::command]
async fn get_overlay_color(state: State<'_, AppState>) -> Result<OverlayColor, String> {
    let color = state.overlay_color.lock().unwrap();
    Ok(color.clone())
}

#[tauri::command]
async fn set_overlay_color(
    state: State<'_, AppState>,
    app_handle: AppHandle,
    color: OverlayColor,
) -> Result<(), String> {
    println!("Setting overlay color to: {}", color.to_rgba_string());

    // Validate color values
    if color.a < 0.0 || color.a > 1.0 {
        return Err("Opacity must be between 0.0 and 1.0".to_string());
    }

    // Update the color in state
    {
        let mut current_color = state.overlay_color.lock().unwrap();
        *current_color = color.clone();
    }

    // Save config
    if let Err(e) = state.save_config().await {
        println!("Warning: Failed to save config: {}", e);
    }

    // Update existing overlays if dimming is enabled
    let is_enabled = {
        let enabled = state.is_dimming_enabled.lock().unwrap();
        *enabled
    };

    if is_enabled {
        // Recreate overlays with new color
        close_all_overlays(&state).await?;
        create_overlays(&app_handle, &state).await?;
    }

    Ok(())
}

#[tauri::command]
async fn reset_overlay_color(
    state: State<'_, AppState>,
    app_handle: AppHandle,
) -> Result<OverlayColor, String> {
    let default_color = OverlayColor::default();

    println!("Resetting overlay color to default: {}", default_color.to_rgba_string());

    // Update the color in state
    {
        let mut current_color = state.overlay_color.lock().unwrap();
        *current_color = default_color.clone();
    }

    // Save config
    if let Err(e) = state.save_config().await {
        println!("Warning: Failed to save config: {}", e);
    }

    // Update existing overlays if dimming is enabled
    let is_enabled = {
        let enabled = state.is_dimming_enabled.lock().unwrap();
        *enabled
    };

    if is_enabled {
        // Recreate overlays with new color
        close_all_overlays(&state).await?;
        create_overlays(&app_handle, &state).await?;
    }

    Ok(default_color)
}

// Helper functions
async fn create_overlays(app_handle: &AppHandle, state: &AppState) -> Result<(), String> {
    let displays = get_displays().await?;
    let mut overlays = state.overlays.lock().unwrap();

    // Get current color from state
    let overlay_color = {
        let color = state.overlay_color.lock().unwrap();
        color.clone()
    };

    // Close existing overlays first
    for (_, window) in overlays.drain() {
        let _ = window.close();
    }

    // Create new overlays for each display
    for display in displays {
        println!("Creating overlay for display: {} at ({}, {}) size: {}x{} with color {}",
                display.name, display.x, display.y, display.width, display.height, overlay_color.to_rgba_string());
        let overlay_id = format!("overlay_{}", display.id);

        match create_overlay_window(app_handle, &overlay_id, &display, &overlay_color) {
            Ok(window) => {
                overlays.insert(display.id.clone(), window);
            }
            Err(e) => {
                log::warn!("Failed to create overlay for display {}: {}", display.id, e);
            }
        }
    }

    Ok(())
}

fn create_dynamic_overlay_html(color: &OverlayColor) -> String {
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotlight Dimmer Overlay</title>
    <style>
        body, html {{
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: {};
            overflow: hidden;
            pointer-events: none;
        }}
    </style>
</head>
<body>
    <!-- This is a transparent overlay that dims the inactive displays -->
</body>
</html>"#,
        color.to_rgba_string()
    )
}

fn create_overlay_window(
    app_handle: &AppHandle,
    overlay_id: &str,
    display: &DisplayInfo,
    color: &OverlayColor,
) -> Result<tauri::WebviewWindow, String> {
    println!("Creating overlay window at position ({}, {}) with size {}x{} and color {}",
             display.x, display.y, display.width, display.height, color.to_rgba_string());

    // Create HTML content with dynamic color for embedded fallback
    let dynamic_overlay_html = create_dynamic_overlay_html(color);

    // Try file-based approach first (preserves transparency), fallback to embedded content
    let window_result = WebviewWindowBuilder::new(app_handle, &format!("{}_file", overlay_id), WebviewUrl::App("overlay.html".into()))
        .title("Spotlight Dimmer Overlay")
        .inner_size(display.width as f64, display.height as f64)
        .position(display.x as f64, display.y as f64)
        .decorations(false)
        .always_on_top(true)
        .skip_taskbar(true)
        .transparent(true)
        .resizable(false)
        .maximizable(false)
        .minimizable(false)
        .closable(false)
        .focusable(false)
        .build();

    let window = match window_result {
        Ok(win) => {
            // For file-based overlays, we need to inject the color via JavaScript
            println!("Using file-based overlay, injecting color via JavaScript");
            let color_js = format!(
                "document.body.style.backgroundColor = '{}';",
                color.to_rgba_string()
            );
            if let Err(e) = win.eval(&color_js) {
                println!("Warning: Failed to inject color into file-based overlay: {}", e);
            }
            win
        },
        Err(_) => {
            // Fallback to embedded content for cargo install with dynamic color
            println!("File-based overlay not found, using embedded content with dynamic color");
            let data_url = format!("data:text/html;charset=utf-8,{}", urlencoding::encode(&dynamic_overlay_html));

            WebviewWindowBuilder::new(app_handle, overlay_id, WebviewUrl::External(data_url.parse().unwrap()))
                .title("Spotlight Dimmer Overlay")
                .inner_size(display.width as f64, display.height as f64)
                .position(display.x as f64, display.y as f64)
                .decorations(false)
                .always_on_top(true)
                .skip_taskbar(true)
                .transparent(true)
                .resizable(false)
                .maximizable(false)
                .minimizable(false)
                .closable(false)
                .focusable(false)
                .build()
                .map_err(|e| format!("Failed to create overlay window with embedded content: {}", e))?
        }
    };

    // Verify the actual window position after creation
    if let (Ok(actual_pos), Ok(actual_size)) = (window.outer_position(), window.outer_size()) {
        println!("Actual window position: ({}, {}), size: {}x{}",
                 actual_pos.x, actual_pos.y, actual_size.width, actual_size.height);

        // Calculate the border size differences
        let width_diff = (actual_size.width as i32) - display.width;
        let height_diff = (actual_size.height as i32) - display.height;

        if width_diff != 0 || height_diff != 0 {
            println!("Window border detected: +{} width, +{} height", width_diff, height_diff);

            // Adjust position to compensate for window borders
            let adjusted_x = display.x - (width_diff / 2);
            let adjusted_y = display.y - (height_diff / 2);

            println!("Adjusting window position to ({}, {})", adjusted_x, adjusted_y);

            // Move the window to the corrected position
            if let Err(e) = window.set_position(tauri::Position::Physical(tauri::PhysicalPosition {
                x: adjusted_x,
                y: adjusted_y,
            })) {
                println!("Failed to adjust window position: {}", e);
            } else {
                println!("Successfully adjusted window position");
            }
        }
    }

    // Add focus event handler to redirect focus back to main window only if spotlight dimmer was previously active
    let app_handle_clone = app_handle.clone();
    window.on_window_event(move |event| {
        match event {
            tauri::WindowEvent::Focused(focused) => {
                if *focused {
                    println!("Overlay window gained focus, checking if should redirect...");

                    // Check if a spotlight dimmer window was the previously active window
                    let should_redirect = {
                        #[cfg(windows)]
                        {
                            let window_manager = platform::WindowsWindowManager;
                            match window_manager.get_active_window() {
                                Ok(active_window) => {
                                    // If we can't determine the active window or it's already an overlay,
                                    // check if any spotlight dimmer window is focused
                                    if active_window.window_title.contains("Spotlight Dimmer") {
                                        true
                                    } else {
                                        // Check if any of our windows are currently focused
                                        let mut spotlight_dimmer_focused = false;
                                        for (label, window) in app_handle_clone.webview_windows() {
                                            if !label.starts_with("overlay_") {
                                                if let Ok(is_focused) = window.is_focused() {
                                                    if is_focused {
                                                        spotlight_dimmer_focused = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        spotlight_dimmer_focused
                                    }
                                }
                                Err(_) => {
                                    // If we can't get active window info, check if any of our main windows are focused
                                    let mut spotlight_dimmer_focused = false;
                                    for (label, window) in app_handle_clone.webview_windows() {
                                        if !label.starts_with("overlay_") {
                                            if let Ok(is_focused) = window.is_focused() {
                                                if is_focused {
                                                    spotlight_dimmer_focused = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    spotlight_dimmer_focused
                                }
                            }
                        }
                        #[cfg(not(windows))]
                        {
                            // Fallback: check if any of our main windows are focused
                            let mut spotlight_dimmer_focused = false;
                            for (label, window) in app_handle_clone.webview_windows() {
                                if !label.starts_with("overlay_") {
                                    if let Ok(is_focused) = window.is_focused() {
                                        if is_focused {
                                            spotlight_dimmer_focused = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            spotlight_dimmer_focused
                        }
                    };

                    if should_redirect {
                        println!("Spotlight dimmer was active, redirecting focus to main window...");

                        // Try to find the main window using common identifiers
                        let possible_main_labels = ["main", "spotlight-dimmer", "Spotlight Dimmer"];
                        let mut main_window_found = false;

                        for label in &possible_main_labels {
                            if let Some(main_window) = app_handle_clone.get_webview_window(label) {
                                if let Err(e) = main_window.set_focus() {
                                    println!("Failed to redirect focus to main window '{}': {}", label, e);
                                } else {
                                    println!("Successfully redirected focus to main window '{}'", label);
                                    main_window_found = true;
                                    break;
                                }
                            }
                        }

                        // If no main window found by label, try to find any non-overlay window
                        if !main_window_found {
                            for (label, window) in app_handle_clone.webview_windows() {
                                if !label.starts_with("overlay_") {
                                    if let Err(e) = window.set_focus() {
                                        println!("Failed to redirect focus to window '{}': {}", label, e);
                                    } else {
                                        println!("Successfully redirected focus to window '{}'", label);
                                        main_window_found = true;
                                        break;
                                    }
                                }
                            }
                        }

                        if !main_window_found {
                            println!("Could not find any main window to redirect focus");
                        }
                    } else {
                        println!("Spotlight dimmer was not active, not redirecting focus");
                    }
                }
            }
            _ => {}
        }
    });

    // Try Tauri's setIgnoreCursorEvents API first
    println!("Attempting to set ignore cursor events...");
    if let Err(e) = window.set_ignore_cursor_events(true) {
        println!("Tauri setIgnoreCursorEvents failed: {}", e);

        // Fallback to Windows API approach
        #[cfg(windows)]
        {
            println!("Falling back to Windows API approach...");
            if let Err(e) = make_window_click_through(&window) {
                println!("Failed to make window click-through with Windows API: {}", e);
            } else {
                println!("Successfully made overlay window click-through with Windows API");
            }
        }
    } else {
        println!("Successfully set ignore cursor events with Tauri API");
    }

    println!("Created overlay window");

    Ok(window)
}

#[cfg(windows)]
fn make_window_click_through(window: &tauri::WebviewWindow) -> Result<(), String> {
    use winapi::um::winuser::{GetWindowLongPtrW, SetWindowLongPtrW, GWL_EXSTYLE, WS_EX_LAYERED, WS_EX_TRANSPARENT, WS_EX_TOOLWINDOW};
    use std::thread;
    use std::time::Duration;

    // Wait a bit to ensure window is fully initialized
    thread::sleep(Duration::from_millis(50));

    let hwnd = window.hwnd().map_err(|e| e.to_string())?;

    unsafe {
        let current_style = GetWindowLongPtrW(hwnd.0 as _, GWL_EXSTYLE);
        println!("Current window style: 0x{:X}", current_style);

        // Apply the click-through flags
        let new_style = current_style | WS_EX_TRANSPARENT as isize | WS_EX_LAYERED as isize | WS_EX_TOOLWINDOW as isize;

        let result = SetWindowLongPtrW(
            hwnd.0 as _,
            GWL_EXSTYLE,
            new_style,
        );

        if result == 0 {
            return Err("SetWindowLongPtrW failed".to_string());
        }

        // Verify the style was applied
        let verify_style = GetWindowLongPtrW(hwnd.0 as _, GWL_EXSTYLE);
        println!("New window style: 0x{:X}", verify_style);
        println!("WS_EX_TRANSPARENT: 0x{:X}", WS_EX_TRANSPARENT);
        println!("WS_EX_LAYERED: 0x{:X}", WS_EX_LAYERED);
        println!("WS_EX_TOOLWINDOW: 0x{:X}", WS_EX_TOOLWINDOW);
    }

    Ok(())
}

async fn close_all_overlays(state: &AppState) -> Result<(), String> {
    let mut overlays = state.overlays.lock().unwrap();
    for (_, window) in overlays.drain() {
        let _ = window.close();
    }
    Ok(())
}

// Synchronous version for display configuration changes
fn recreate_overlays_for_display_change(app_handle: &AppHandle, state: &AppState) -> Result<(), String> {
    // Only recreate overlays if dimming is enabled
    let is_enabled = {
        let enabled = state.is_dimming_enabled.lock().unwrap();
        *enabled
    };

    if !is_enabled {
        println!("Dimming disabled, skipping overlay recreation");
        return Ok(());
    }

    println!("Recreating overlays for display configuration change...");

    // Get current display list
    let displays = {
        #[cfg(windows)]
        {
            let display_manager = platform::WindowsDisplayManager;
            display_manager.get_displays()
        }
        #[cfg(not(windows))]
        {
            Err("Platform not supported yet".to_string())
        }
    }?;

    // Get current overlay color
    let overlay_color = {
        let color = state.overlay_color.lock().unwrap();
        color.clone()
    };

    // Close all existing overlays and clear the HashMap
    {
        let mut overlays = state.overlays.lock().unwrap();
        for (_, window) in overlays.drain() {
            let _ = window.close();
        }
        println!("Closed all existing overlays");
    }

    // Create new overlays for current displays
    {
        let mut overlays = state.overlays.lock().unwrap();
        for display in displays {
            println!("Creating overlay for display: {} at ({}, {}) size: {}x{}",
                    display.name, display.x, display.y, display.width, display.height);
            let overlay_id = format!("overlay_{}", display.id);

            match create_overlay_window(app_handle, &overlay_id, &display, &overlay_color) {
                Ok(window) => {
                    overlays.insert(display.id.clone(), window);
                }
                Err(e) => {
                    println!("Failed to create overlay for display {}: {}", display.id, e);
                }
            }
        }
    }

    // Reset active display tracking to ensure proper overlay visibility
    {
        let mut current_display = state.current_active_display.lock().unwrap();
        *current_display = None;
    }

    println!("Overlay recreation completed successfully");
    Ok(())
}

async fn update_overlays(app_handle: &AppHandle, state: &AppState) -> Result<(), String> {
    let is_enabled = *state.is_dimming_enabled.lock().unwrap();
    if !is_enabled {
        return Ok(());
    }

    let active_window = get_active_window().await?;

    // Only update if the active display changed
    let should_update = {
        let mut current_display = state.current_active_display.lock().unwrap();
        if current_display.as_ref() != Some(&active_window.display_id) {
            *current_display = Some(active_window.display_id.clone());
            true
        } else {
            false
        }
    };

    if should_update {
        // Update overlay visibility
        {
            let overlays = state.overlays.lock().unwrap();
            for (display_id, window) in overlays.iter() {
                let should_hide = display_id == &active_window.display_id;
                if should_hide {
                    let _ = window.hide();
                } else {
                    let _ = window.show();
                }
            }
        }

        // Emit focus change event
        let displays = get_displays().await?;
        if let Some(active_display) = displays.iter().find(|d| d.id == active_window.display_id) {
            let focus_event = FocusChangeEvent {
                active_window,
                active_display: active_display.clone(),
            };

            if let Err(e) = app_handle.emit("focus-changed", &focus_event) {
                log::warn!("Failed to emit focus-changed event: {}", e);
            }
        }
    }

    Ok(())
}

// Synchronous version of update_overlays for background thread
fn update_overlays_sync(app_handle: &AppHandle, state: &AppState, active_window: &ActiveWindowInfo) -> Result<(), String> {
    let is_enabled = *state.is_dimming_enabled.lock().unwrap();
    if !is_enabled {
        return Ok(());
    }

    // Only update if the active display changed
    let should_update = {
        let mut current_display = state.current_active_display.lock().unwrap();
        if current_display.as_ref() != Some(&active_window.display_id) {
            *current_display = Some(active_window.display_id.clone());
            true
        } else {
            false
        }
    };

    if should_update {
        // Update overlay visibility
        {
            let overlays = state.overlays.lock().unwrap();
            for (display_id, window) in overlays.iter() {
                let should_hide = display_id == &active_window.display_id;
                if should_hide {
                    let _ = window.hide();
                } else {
                    let _ = window.show();
                }
            }
        }

        // Emit focus change event (sync version)
        let displays_result = {
            #[cfg(windows)]
            {
                let display_manager = platform::WindowsDisplayManager;
                display_manager.get_displays()
            }
            #[cfg(not(windows))]
            {
                Err("Platform not supported yet".to_string())
            }
        };

        if let Ok(displays) = displays_result {
            if let Some(active_display) = displays.iter().find(|d| d.id == active_window.display_id) {
                let focus_event = FocusChangeEvent {
                    active_window: active_window.clone(),
                    active_display: active_display.clone(),
                };

                if let Err(e) = app_handle.emit("focus-changed", &focus_event) {
                    println!("Failed to emit focus-changed event: {}", e);
                } else {
                    println!("Successfully emitted focus-changed event for: {}", active_window.window_title);
                }
            }
        }
    }

    Ok(())
}

// Tauri commands for tray functionality
#[tauri::command]
async fn show_main_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("main") {
        window.show().map_err(|e| e.to_string())?;
        window.set_focus().map_err(|e| e.to_string())?;
        Ok(())
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn hide_main_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("main") {
        window.hide().map_err(|e| e.to_string())?;
        Ok(())
    } else {
        Err("Main window not found".to_string())
    }
}

// System tray setup function
fn setup_system_tray(app: &tauri::App) -> tauri::Result<()> {
    // Create tray menu
    let show_item = MenuItem::with_id(app, "show", "Show Spotlight Dimmer", true, None::<&str>)?;
    let hide_item = MenuItem::with_id(app, "hide", "Hide to Tray", true, None::<&str>)?;
    let separator = PredefinedMenuItem::separator(app)?;
    let quit_item = MenuItem::with_id(app, "quit", "Exit", true, None::<&str>)?;

    let menu = Menu::with_items(app, &[&show_item, &hide_item, &separator, &quit_item])?;

    // Create and configure tray icon
    let _tray = TrayIconBuilder::new()
        .icon(app.default_window_icon().unwrap().clone())
        .menu(&menu)
        .tooltip("Spotlight Dimmer")
        .on_menu_event(|app, event| match event.id.as_ref() {
            "show" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                    let _ = window.set_focus();
                }
            }
            "hide" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.hide();
                }
            }
            "quit" => {
                app.exit(0);
            }
            _ => {}
        })
        .on_tray_icon_event(|tray, event| {
            // Handle left click to toggle window visibility
            if let TrayIconEvent::Click { button: MouseButton::Left, .. } = event {
                let app = tray.app_handle();
                if let Some(window) = app.get_webview_window("main") {
                    match window.is_visible() {
                        Ok(true) => {
                            let _ = window.hide();
                        }
                        Ok(false) => {
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                        Err(_) => {
                            // If we can't determine visibility, try to show
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                    }
                }
            }
        })
        .build(app)?;

    Ok(())
}

// Focus monitoring setup
fn start_focus_monitoring(app_handle: AppHandle) {
    std::thread::spawn(move || {
        let mut last_window_handle: Option<u64> = None;
        let mut last_display_id: Option<String> = None;
        let mut last_display_count: Option<usize> = None;
        println!("Focus monitoring thread started!");

        loop {
            std::thread::sleep(std::time::Duration::from_millis(100));

            // Check for display configuration changes (lightweight)
            if let Ok(current_display_count) = get_display_count() {
                if Some(current_display_count) != last_display_count {
                    println!("Display configuration changed: {} -> {} displays",
                        last_display_count.unwrap_or(0), current_display_count);

                    // Display configuration changed - recreate overlays
                    let state = app_handle.state::<AppState>();
                    if let Err(e) = recreate_overlays_for_display_change(&app_handle, &state) {
                        println!("Failed to recreate overlays after display change: {}", e);
                    } else {
                        println!("Successfully recreated overlays for new display configuration");
                    }

                    last_display_count = Some(current_display_count);
                    // Reset tracking since display configuration changed
                    last_window_handle = None;
                    last_display_id = None;
                    continue; // Skip normal processing this cycle
                }
            }

            // Create a sync version of get_active_window
            let active_window_result = {
                #[cfg(windows)]
                {
                    let window_manager = platform::WindowsWindowManager;
                    window_manager.get_active_window()
                }
                #[cfg(not(windows))]
                {
                    Err("Platform not supported yet".to_string())
                }
            };

            match active_window_result {
                Ok(active_window) => {
                    // Skip our own overlay windows to prevent focus stealing loops
                    if active_window.window_title.contains("Spotlight Dimmer Overlay") {
                        continue;
                    }

                    // Check if either the window handle OR the display has changed
                    let window_changed = Some(active_window.handle) != last_window_handle;
                    let display_changed = last_display_id.as_ref() != Some(&active_window.display_id);

                    if window_changed || display_changed {
                        if window_changed {
                            println!("Active window changed: {} ({})", active_window.window_title, active_window.process_name);
                        }
                        if display_changed && !window_changed {
                            println!("Window moved to different display: {} -> {}",
                                last_display_id.as_ref().unwrap_or(&"unknown".to_string()),
                                active_window.display_id);
                        }

                        last_window_handle = Some(active_window.handle);
                        last_display_id = Some(active_window.display_id.clone());

                        let state = app_handle.state::<AppState>();

                        // Use a blocking approach for updates
                        if let Err(e) = update_overlays_sync(&app_handle, &state, &active_window) {
                            println!("Failed to update overlays: {}", e);
                        }
                    }
                },
                Err(e) => {
                    if last_window_handle.is_some() {
                        println!("Failed to get active window: {}", e);
                        last_window_handle = None;
                        last_display_id = None;
                    }
                }
            }
        }
    });
}


#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .manage(AppState::default())
        .plugin(tauri_plugin_log::Builder::default()
            .level(log::LevelFilter::Info)
            .build())
        .setup(|app| {
            let app_handle = app.handle().clone();

            // Load saved configuration
            let state = app.state::<AppState>();
            if let Err(e) = tokio::runtime::Runtime::new().unwrap().block_on(state.load_config(&app_handle)) {
                println!("Warning: Failed to load config: {}", e);
            }

            // Setup system tray
            setup_system_tray(app)?;

            // Start focus monitoring
            start_focus_monitoring(app_handle.clone());

            // Auto-create overlays since dimming starts enabled
            println!("Auto-creating overlays on startup...");

            // Clone for the thread
            let app_handle_clone = app_handle.clone();

            // Use a small delay to ensure the app is fully initialized
            std::thread::spawn(move || {
                std::thread::sleep(std::time::Duration::from_millis(500));
                let state_clone = app_handle_clone.state::<AppState>();
                if let Err(e) = tokio::runtime::Runtime::new().unwrap().block_on(create_overlays(&app_handle_clone, &state_clone)) {
                    println!("Failed to auto-create overlays on startup: {}", e);
                } else {
                    println!("Successfully auto-created overlays on startup");
                    println!("Spotlight Dimmer started in tray - click tray icon to open interface");
                }
            });

            Ok(())
        })
        .on_window_event(|window, event| match event {
            tauri::WindowEvent::CloseRequested { api, .. } => {
                // Only intercept close for main window, let overlays close normally
                if window.label() == "main" {
                    println!("Intercepting main window close, hiding to tray instead");
                    let _ = window.hide();
                    api.prevent_close();
                } else {
                    println!("Allowing overlay window '{}' to close normally", window.label());
                }
            }
            _ => {}
        })
        .invoke_handler(tauri::generate_handler![
            get_displays,
            get_active_window,
            toggle_dimming,
            is_dimming_enabled,
            get_overlay_color,
            set_overlay_color,
            reset_overlay_color,
            show_main_window,
            hide_main_window
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
