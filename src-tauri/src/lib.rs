mod platform;

// Include the embedded assets generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_assets.rs"));

use platform::{ActiveWindowInfo, DisplayInfo, DisplayManager, WindowManager};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tauri::{
    AppHandle, Manager, State, WebviewUrl, WebviewWindowBuilder, Emitter,
    tray::{TrayIconBuilder, TrayIconEvent, MouseButton},
    menu::{Menu, MenuItem, PredefinedMenuItem},
};

// Global state for managing overlays and focus tracking
struct AppState {
    overlays: Arc<Mutex<HashMap<String, tauri::WebviewWindow>>>,
    is_dimming_enabled: Arc<Mutex<bool>>,
    current_active_display: Arc<Mutex<Option<String>>>,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            overlays: Arc::new(Mutex::new(HashMap::new())),
            is_dimming_enabled: Arc::new(Mutex::new(true)), // Start with dimming enabled
            current_active_display: Arc::new(Mutex::new(None)),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
struct FocusChangeEvent {
    active_window: ActiveWindowInfo,
    active_display: DisplayInfo,
}

// Tauri commands
#[tauri::command]
async fn get_displays() -> Result<Vec<DisplayInfo>, String> {
    #[cfg(windows)]
    {
        let display_manager = platform::WindowsDisplayManager;
        display_manager.get_displays()
    }
    #[cfg(not(windows))]
    {
        Err("Platform not supported yet".to_string())
    }
}

#[tauri::command]
async fn get_active_window() -> Result<ActiveWindowInfo, String> {
    #[cfg(windows)]
    {
        let window_manager = platform::WindowsWindowManager;
        window_manager.get_active_window()
    }
    #[cfg(not(windows))]
    {
        Err("Platform not supported yet".to_string())
    }
}

#[tauri::command]
async fn toggle_dimming(
    state: State<'_, AppState>,
    app_handle: AppHandle,
) -> Result<bool, String> {
    println!("Toggle dimming called!");

    // Fix: Use scope to drop mutex guard before await
    let is_enabled = {
        let mut enabled = state.is_dimming_enabled.lock().unwrap();
        *enabled = !*enabled;
        *enabled
    };

    println!("Dimming is now: {}", is_enabled);

    if is_enabled {
        println!("Creating overlays...");
        create_overlays(&app_handle, &state).await?;
        println!("Overlays creation completed");
    } else {
        println!("Closing overlays...");
        close_all_overlays(&state).await?;
        println!("Overlays closed");
    }

    Ok(is_enabled)
}

#[tauri::command]
async fn is_dimming_enabled(state: State<'_, AppState>) -> Result<bool, String> {
    let is_enabled = state.is_dimming_enabled.lock().unwrap();
    Ok(*is_enabled)
}

// Helper functions
async fn create_overlays(app_handle: &AppHandle, state: &AppState) -> Result<(), String> {
    let displays = get_displays().await?;
    let mut overlays = state.overlays.lock().unwrap();

    // Close existing overlays first
    for (_, window) in overlays.drain() {
        let _ = window.close();
    }

    // Create new overlays for each display
    for display in displays {
        println!("Creating overlay for display: {} at ({}, {}) size: {}x{}",
                display.name, display.x, display.y, display.width, display.height);
        let overlay_id = format!("overlay_{}", display.id);

        match create_overlay_window(app_handle, &overlay_id, &display) {
            Ok(window) => {
                overlays.insert(display.id.clone(), window);
            }
            Err(e) => {
                log::warn!("Failed to create overlay for display {}: {}", display.id, e);
            }
        }
    }

    Ok(())
}

fn create_overlay_window(
    app_handle: &AppHandle,
    overlay_id: &str,
    display: &DisplayInfo,
) -> Result<tauri::WebviewWindow, String> {
    println!("Creating overlay window at position ({}, {}) with size {}x{}",
             display.x, display.y, display.width, display.height);

    // Try file-based approach first (preserves transparency), fallback to embedded content
    let window_result = WebviewWindowBuilder::new(app_handle, &format!("{}_file", overlay_id), WebviewUrl::App("overlay.html".into()))
        .title("Spotlight Dimmer Overlay")
        .inner_size(display.width as f64, display.height as f64)
        .position(display.x as f64, display.y as f64)
        .decorations(false)
        .always_on_top(true)
        .skip_taskbar(true)
        .transparent(true)
        .resizable(false)
        .maximizable(false)
        .minimizable(false)
        .closable(false)
        .focusable(false)
        .build();

    let window = match window_result {
        Ok(win) => win,
        Err(_) => {
            // Fallback to embedded content for cargo install
            println!("File-based overlay not found, using embedded content");
            let overlay_html_content = get_asset("overlay.html").unwrap_or(OVERLAY_HTML);
            let data_url = format!("data:text/html;charset=utf-8,{}", urlencoding::encode(overlay_html_content));

            WebviewWindowBuilder::new(app_handle, overlay_id, WebviewUrl::External(data_url.parse().unwrap()))
                .title("Spotlight Dimmer Overlay")
                .inner_size(display.width as f64, display.height as f64)
                .position(display.x as f64, display.y as f64)
                .decorations(false)
                .always_on_top(true)
                .skip_taskbar(true)
                .transparent(true)
                .resizable(false)
                .maximizable(false)
                .minimizable(false)
                .closable(false)
                .focusable(false)
                .build()
                .map_err(|e| format!("Failed to create overlay window with embedded content: {}", e))?
        }
    };

    // Verify the actual window position after creation
    if let (Ok(actual_pos), Ok(actual_size)) = (window.outer_position(), window.outer_size()) {
        println!("Actual window position: ({}, {}), size: {}x{}",
                 actual_pos.x, actual_pos.y, actual_size.width, actual_size.height);

        // Calculate the border size differences
        let width_diff = (actual_size.width as i32) - display.width;
        let height_diff = (actual_size.height as i32) - display.height;

        if width_diff != 0 || height_diff != 0 {
            println!("Window border detected: +{} width, +{} height", width_diff, height_diff);

            // Adjust position to compensate for window borders
            let adjusted_x = display.x - (width_diff / 2);
            let adjusted_y = display.y - (height_diff / 2);

            println!("Adjusting window position to ({}, {})", adjusted_x, adjusted_y);

            // Move the window to the corrected position
            if let Err(e) = window.set_position(tauri::Position::Physical(tauri::PhysicalPosition {
                x: adjusted_x,
                y: adjusted_y,
            })) {
                println!("Failed to adjust window position: {}", e);
            } else {
                println!("Successfully adjusted window position");
            }
        }
    }

    // Add focus event handler to redirect focus back to main window only if spotlight dimmer was previously active
    let app_handle_clone = app_handle.clone();
    window.on_window_event(move |event| {
        match event {
            tauri::WindowEvent::Focused(focused) => {
                if *focused {
                    println!("Overlay window gained focus, checking if should redirect...");

                    // Check if a spotlight dimmer window was the previously active window
                    let should_redirect = {
                        #[cfg(windows)]
                        {
                            let window_manager = platform::WindowsWindowManager;
                            match window_manager.get_active_window() {
                                Ok(active_window) => {
                                    // If we can't determine the active window or it's already an overlay,
                                    // check if any spotlight dimmer window is focused
                                    if active_window.window_title.contains("Spotlight Dimmer") {
                                        true
                                    } else {
                                        // Check if any of our windows are currently focused
                                        let mut spotlight_dimmer_focused = false;
                                        for (label, window) in app_handle_clone.webview_windows() {
                                            if !label.starts_with("overlay_") {
                                                if let Ok(is_focused) = window.is_focused() {
                                                    if is_focused {
                                                        spotlight_dimmer_focused = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        spotlight_dimmer_focused
                                    }
                                }
                                Err(_) => {
                                    // If we can't get active window info, check if any of our main windows are focused
                                    let mut spotlight_dimmer_focused = false;
                                    for (label, window) in app_handle_clone.webview_windows() {
                                        if !label.starts_with("overlay_") {
                                            if let Ok(is_focused) = window.is_focused() {
                                                if is_focused {
                                                    spotlight_dimmer_focused = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    spotlight_dimmer_focused
                                }
                            }
                        }
                        #[cfg(not(windows))]
                        {
                            // Fallback: check if any of our main windows are focused
                            let mut spotlight_dimmer_focused = false;
                            for (label, window) in app_handle_clone.webview_windows() {
                                if !label.starts_with("overlay_") {
                                    if let Ok(is_focused) = window.is_focused() {
                                        if is_focused {
                                            spotlight_dimmer_focused = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            spotlight_dimmer_focused
                        }
                    };

                    if should_redirect {
                        println!("Spotlight dimmer was active, redirecting focus to main window...");

                        // Try to find the main window using common identifiers
                        let possible_main_labels = ["main", "spotlight-dimmer", "Spotlight Dimmer"];
                        let mut main_window_found = false;

                        for label in &possible_main_labels {
                            if let Some(main_window) = app_handle_clone.get_webview_window(label) {
                                if let Err(e) = main_window.set_focus() {
                                    println!("Failed to redirect focus to main window '{}': {}", label, e);
                                } else {
                                    println!("Successfully redirected focus to main window '{}'", label);
                                    main_window_found = true;
                                    break;
                                }
                            }
                        }

                        // If no main window found by label, try to find any non-overlay window
                        if !main_window_found {
                            for (label, window) in app_handle_clone.webview_windows() {
                                if !label.starts_with("overlay_") {
                                    if let Err(e) = window.set_focus() {
                                        println!("Failed to redirect focus to window '{}': {}", label, e);
                                    } else {
                                        println!("Successfully redirected focus to window '{}'", label);
                                        main_window_found = true;
                                        break;
                                    }
                                }
                            }
                        }

                        if !main_window_found {
                            println!("Could not find any main window to redirect focus");
                        }
                    } else {
                        println!("Spotlight dimmer was not active, not redirecting focus");
                    }
                }
            }
            _ => {}
        }
    });

    // Try Tauri's setIgnoreCursorEvents API first
    println!("Attempting to set ignore cursor events...");
    if let Err(e) = window.set_ignore_cursor_events(true) {
        println!("Tauri setIgnoreCursorEvents failed: {}", e);

        // Fallback to Windows API approach
        #[cfg(windows)]
        {
            println!("Falling back to Windows API approach...");
            if let Err(e) = make_window_click_through(&window) {
                println!("Failed to make window click-through with Windows API: {}", e);
            } else {
                println!("Successfully made overlay window click-through with Windows API");
            }
        }
    } else {
        println!("Successfully set ignore cursor events with Tauri API");
    }

    println!("Created overlay window");

    Ok(window)
}

#[cfg(windows)]
fn make_window_click_through(window: &tauri::WebviewWindow) -> Result<(), String> {
    use winapi::um::winuser::{GetWindowLongPtrW, SetWindowLongPtrW, GWL_EXSTYLE, WS_EX_LAYERED, WS_EX_TRANSPARENT, WS_EX_TOOLWINDOW};
    use std::thread;
    use std::time::Duration;

    // Wait a bit to ensure window is fully initialized
    thread::sleep(Duration::from_millis(50));

    let hwnd = window.hwnd().map_err(|e| e.to_string())?;

    unsafe {
        let current_style = GetWindowLongPtrW(hwnd.0 as _, GWL_EXSTYLE);
        println!("Current window style: 0x{:X}", current_style);

        // Apply the click-through flags
        let new_style = current_style | WS_EX_TRANSPARENT as isize | WS_EX_LAYERED as isize | WS_EX_TOOLWINDOW as isize;

        let result = SetWindowLongPtrW(
            hwnd.0 as _,
            GWL_EXSTYLE,
            new_style,
        );

        if result == 0 {
            return Err("SetWindowLongPtrW failed".to_string());
        }

        // Verify the style was applied
        let verify_style = GetWindowLongPtrW(hwnd.0 as _, GWL_EXSTYLE);
        println!("New window style: 0x{:X}", verify_style);
        println!("WS_EX_TRANSPARENT: 0x{:X}", WS_EX_TRANSPARENT);
        println!("WS_EX_LAYERED: 0x{:X}", WS_EX_LAYERED);
        println!("WS_EX_TOOLWINDOW: 0x{:X}", WS_EX_TOOLWINDOW);
    }

    Ok(())
}

async fn close_all_overlays(state: &AppState) -> Result<(), String> {
    let mut overlays = state.overlays.lock().unwrap();
    for (_, window) in overlays.drain() {
        let _ = window.close();
    }
    Ok(())
}

async fn update_overlays(app_handle: &AppHandle, state: &AppState) -> Result<(), String> {
    let is_enabled = *state.is_dimming_enabled.lock().unwrap();
    if !is_enabled {
        return Ok(());
    }

    let active_window = get_active_window().await?;

    // Only update if the active display changed
    let should_update = {
        let mut current_display = state.current_active_display.lock().unwrap();
        if current_display.as_ref() != Some(&active_window.display_id) {
            *current_display = Some(active_window.display_id.clone());
            true
        } else {
            false
        }
    };

    if should_update {
        // Update overlay visibility
        {
            let overlays = state.overlays.lock().unwrap();
            for (display_id, window) in overlays.iter() {
                let should_hide = display_id == &active_window.display_id;
                if should_hide {
                    let _ = window.hide();
                } else {
                    let _ = window.show();
                }
            }
        }

        // Emit focus change event
        let displays = get_displays().await?;
        if let Some(active_display) = displays.iter().find(|d| d.id == active_window.display_id) {
            let focus_event = FocusChangeEvent {
                active_window,
                active_display: active_display.clone(),
            };

            if let Err(e) = app_handle.emit("focus-changed", &focus_event) {
                log::warn!("Failed to emit focus-changed event: {}", e);
            }
        }
    }

    Ok(())
}

// Synchronous version of update_overlays for background thread
fn update_overlays_sync(app_handle: &AppHandle, state: &AppState, active_window: &ActiveWindowInfo) -> Result<(), String> {
    let is_enabled = *state.is_dimming_enabled.lock().unwrap();
    if !is_enabled {
        return Ok(());
    }

    // Only update if the active display changed
    let should_update = {
        let mut current_display = state.current_active_display.lock().unwrap();
        if current_display.as_ref() != Some(&active_window.display_id) {
            *current_display = Some(active_window.display_id.clone());
            true
        } else {
            false
        }
    };

    if should_update {
        // Update overlay visibility
        {
            let overlays = state.overlays.lock().unwrap();
            for (display_id, window) in overlays.iter() {
                let should_hide = display_id == &active_window.display_id;
                if should_hide {
                    let _ = window.hide();
                } else {
                    let _ = window.show();
                }
            }
        }

        // Emit focus change event (sync version)
        let displays_result = {
            #[cfg(windows)]
            {
                let display_manager = platform::WindowsDisplayManager;
                display_manager.get_displays()
            }
            #[cfg(not(windows))]
            {
                Err("Platform not supported yet".to_string())
            }
        };

        if let Ok(displays) = displays_result {
            if let Some(active_display) = displays.iter().find(|d| d.id == active_window.display_id) {
                let focus_event = FocusChangeEvent {
                    active_window: active_window.clone(),
                    active_display: active_display.clone(),
                };

                if let Err(e) = app_handle.emit("focus-changed", &focus_event) {
                    println!("Failed to emit focus-changed event: {}", e);
                } else {
                    println!("Successfully emitted focus-changed event for: {}", active_window.window_title);
                }
            }
        }
    }

    Ok(())
}

// Tauri commands for tray functionality
#[tauri::command]
async fn show_main_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("main") {
        window.show().map_err(|e| e.to_string())?;
        window.set_focus().map_err(|e| e.to_string())?;
        Ok(())
    } else {
        Err("Main window not found".to_string())
    }
}

#[tauri::command]
async fn hide_main_window(app: AppHandle) -> Result<(), String> {
    if let Some(window) = app.get_webview_window("main") {
        window.hide().map_err(|e| e.to_string())?;
        Ok(())
    } else {
        Err("Main window not found".to_string())
    }
}

// System tray setup function
fn setup_system_tray(app: &tauri::App) -> tauri::Result<()> {
    // Create tray menu
    let show_item = MenuItem::with_id(app, "show", "Show Spotlight Dimmer", true, None::<&str>)?;
    let hide_item = MenuItem::with_id(app, "hide", "Hide to Tray", true, None::<&str>)?;
    let separator = PredefinedMenuItem::separator(app)?;
    let quit_item = MenuItem::with_id(app, "quit", "Exit", true, None::<&str>)?;

    let menu = Menu::with_items(app, &[&show_item, &hide_item, &separator, &quit_item])?;

    // Create and configure tray icon
    let _tray = TrayIconBuilder::new()
        .menu(&menu)
        .tooltip("Spotlight Dimmer")
        .on_menu_event(|app, event| match event.id.as_ref() {
            "show" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.show();
                    let _ = window.set_focus();
                }
            }
            "hide" => {
                if let Some(window) = app.get_webview_window("main") {
                    let _ = window.hide();
                }
            }
            "quit" => {
                app.exit(0);
            }
            _ => {}
        })
        .on_tray_icon_event(|tray, event| {
            // Handle left click to toggle window visibility
            if let TrayIconEvent::Click { button: MouseButton::Left, .. } = event {
                let app = tray.app_handle();
                if let Some(window) = app.get_webview_window("main") {
                    match window.is_visible() {
                        Ok(true) => {
                            let _ = window.hide();
                        }
                        Ok(false) => {
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                        Err(_) => {
                            // If we can't determine visibility, try to show
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                    }
                }
            }
        })
        .build(app)?;

    Ok(())
}

// Focus monitoring setup
fn start_focus_monitoring(app_handle: AppHandle) {
    std::thread::spawn(move || {
        let mut last_window_handle: Option<u64> = None;
        let mut last_display_id: Option<String> = None;
        println!("Focus monitoring thread started!");

        loop {
            std::thread::sleep(std::time::Duration::from_millis(100));

            // Create a sync version of get_active_window
            let active_window_result = {
                #[cfg(windows)]
                {
                    let window_manager = platform::WindowsWindowManager;
                    window_manager.get_active_window()
                }
                #[cfg(not(windows))]
                {
                    Err("Platform not supported yet".to_string())
                }
            };

            match active_window_result {
                Ok(active_window) => {
                    // Skip our own overlay windows to prevent focus stealing loops
                    if active_window.window_title.contains("Spotlight Dimmer Overlay") {
                        continue;
                    }

                    // Check if either the window handle OR the display has changed
                    let window_changed = Some(active_window.handle) != last_window_handle;
                    let display_changed = last_display_id.as_ref() != Some(&active_window.display_id);

                    if window_changed || display_changed {
                        if window_changed {
                            println!("Active window changed: {} ({})", active_window.window_title, active_window.process_name);
                        }
                        if display_changed && !window_changed {
                            println!("Window moved to different display: {} -> {}",
                                last_display_id.as_ref().unwrap_or(&"unknown".to_string()),
                                active_window.display_id);
                        }

                        last_window_handle = Some(active_window.handle);
                        last_display_id = Some(active_window.display_id.clone());

                        let state = app_handle.state::<AppState>();

                        // Use a blocking approach for updates
                        if let Err(e) = update_overlays_sync(&app_handle, &state, &active_window) {
                            println!("Failed to update overlays: {}", e);
                        }
                    }
                },
                Err(e) => {
                    if last_window_handle.is_some() {
                        println!("Failed to get active window: {}", e);
                        last_window_handle = None;
                        last_display_id = None;
                    }
                }
            }
        }
    });
}


#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .manage(AppState::default())
        .plugin(tauri_plugin_log::Builder::default()
            .level(log::LevelFilter::Info)
            .build())
        .setup(|app| {
            let app_handle = app.handle().clone();

            // Setup system tray
            setup_system_tray(app)?;

            // Start focus monitoring
            start_focus_monitoring(app_handle.clone());

            // Auto-create overlays since dimming starts enabled
            println!("Auto-creating overlays on startup...");

            // Clone for the thread
            let app_handle_clone = app_handle.clone();

            // Use a small delay to ensure the app is fully initialized
            std::thread::spawn(move || {
                std::thread::sleep(std::time::Duration::from_millis(500));
                let state_clone = app_handle_clone.state::<AppState>();
                if let Err(e) = tokio::runtime::Runtime::new().unwrap().block_on(create_overlays(&app_handle_clone, &state_clone)) {
                    println!("Failed to auto-create overlays on startup: {}", e);
                } else {
                    println!("Successfully auto-created overlays on startup");
                }
            });

            Ok(())
        })
        .on_window_event(|window, event| match event {
            tauri::WindowEvent::CloseRequested { api, .. } => {
                // Only intercept close for main window, let overlays close normally
                if window.label() == "main" {
                    println!("Intercepting main window close, hiding to tray instead");
                    let _ = window.hide();
                    api.prevent_close();
                } else {
                    println!("Allowing overlay window '{}' to close normally", window.label());
                }
            }
            _ => {}
        })
        .invoke_handler(tauri::generate_handler![
            get_displays,
            get_active_window,
            toggle_dimming,
            is_dimming_enabled,
            show_main_window,
            hide_main_window
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
